/*
Se soporta todo lo pedido en sprints anteriores.Incluyendo el comando expressor de
consola del spec original.
*/
print("*********************** HelloWorld0 ***********************")
let x = 666
print(x)
let y = 10
print(y)

print("*********************** HelloWorld1 ***********************")
let x = 6
print(x)
let y = 3
print(y)
let f = (x, z) -> z ** x + x*z + 1
print(f(x, y)) // Expected 748

print("*********************** HelloWorld2 ***********************")
let isZero = x -> x ? 0 : 1
let TRUE  = 1
let FALSE = 0
let isTrue = x -> isZero(x) ? TRUE : FALSE
let NOT = x -> x ? 0 : 1
let OR =  (x, y) -> isTrue(x) ? TRUE : isTrue(y)
let AND = (x, y) -> isTrue(x) ? isTrue(y) : FALSE
let XOR = (x, y) -> AND(OR(x, y), NOT(AND(x, y)))
print(XOR(TRUE, TRUE))   // Expected 0
print(XOR(TRUE, FALSE))  // Expected 1
print(XOR(FALSE, TRUE))  // Expected 1
print(XOR(FALSE, FALSE)) // Expected 0






print( " ******************** TC1: Casos con Nuevos Tipos Primitivos ******************** " )
/*
TC1: Casos con Nuevos Tipos Primitivos 
Prueban uso de nuevos tipos y operaciones primitivas con y entre ellos. Se prueban con
funciones incluyendo fun y recursividad.
*/

fun fill(n:int, s:string):string = n == 0 ? "" : ( s + fill(n - 1, s) )
print(fill(10, "a"))




print( " ******************** TC2: Declaraciones explicitas y Castings. ******************** " )
/*
Prueban que se generan transpilan correctamente las declaraciones de tipos explícitas ( : ) a
Java . Incluyen casos de castings.
*/

let foo:int = 1 // should create a int foo = 1;
print (foo:string + ".000") // should output 1.000 
Print("7+1":int) //should output 8
Print("3/2":float) //should output 1.5





print( " ******************** TC3: Casos de Declaraciones data y ^ ******************** " )
/*
Prueban que los data se transpilan correctamente a Java y que se pueden instanciar
(operador ^ ).
*/

data person = {
    name,
    age,
    gender,
    p_acocunt:account
}

data account = {
    id:string,
    balance:int 
}

let p1 = ^person("Antony",28,"Male",^account("a-123",123))
print (p1)




print( " ******************** TC4: Casos con Pattern-Matching (expresión match ) ******************** " )
/*
Prueban que match se transpila correctamente a Java y funciona correctamente en
conjunción con data y ^ .
*/

data shape = {
    Circle(radius:float),
    Rectangle(length:float, width:float)
}

fun getPerimeter(s:shape):float =
    match s {
        case Circle(r) => 2 * r * 3.14159
        case Rectangle(l, w) => 2 * l + 2 * w
        default => error("Unrecognized shape")
    }

let c = ^Circle(5.0)
let r = ^Rectangle(3.0, 4.0)

print(getPerimeter(c))
print(getPerimeter(r))